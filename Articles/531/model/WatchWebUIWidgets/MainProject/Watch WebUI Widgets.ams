## ams_version=1.0

Model Main_Watch_WebUI_Widgets {
	Section Quantities_and_Units {
		Comment: {
			"This section contains all the units and quantities that are added automatically by AIMMS.
			It is recommended to declare all your quantities here."
		}
		Quantity SI_Time_Duration {
			BaseUnit: hour;
			Conversions: {
				minute ->hour : #-># / 60,
				century->hour : #-># * 876000,
				day    ->hour : #-># * 24,
				s      ->hour : #-># / 3600,
				month  ->hour : #-># * 730,
				second ->hour : #-># / 3600,
				tick   ->hour : #-># / 360000,
				week   ->hour : #-># * 168,
				year   ->hour : #-># * 8760
			}
			Comment: "Expresses the value for the duration of periods.";
		}
	}
	Section WebUI_globals {
		StringParameter sp_wwwWorkflow {
			IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			Definition: {
				{
					('1', 'title') : "Demos" , ! (Optional) The title for the Workflow to be displayed on top of the Workflow Panel.
					('1', 'style') : ""   ! (CURRENTLY NOT IN USE) When styles or themes are introduced for the Workflow Panel, this attribute will hold that value.
				}
			}
		}
		StringParameter sp_wwwWorkflowSteps {
			IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
			Definition: {
				{
					( '1', '1', 'displayText'       ) : "Welcome",  
					( '1', '1', 'icon'              ) : "aimms-happy",  
					( '1', '1', 'pageId'            ) : "home", 
					( '1', '1', 'tooltip'           ) : "Shows a text widget welcoming you to this app", 
					( '1', '1', 'workflowPageState' ) : "Active", 
					( '1', '1', 'pageDataState'     ) : "", 
					( '1', '1', 'redirectPageId'    ) : "home", 
				
					( '1', '2', 'displayText'       ) : "Map", 
					( '1', '2', 'icon'              ) : "aimms-map", 
					( '1', '2', 'pageId'            ) : "map", 
					( '1', '2', 'tooltip'           ) : "Shows a map widget with the OxyGem network", 
					( '1', '2', 'workflowPageState' ) : "Active", 
					( '1', '2', 'pageDataState'     ) : "", 
					( '1', '2', 'redirectPageId'    ) : "home",
				
					( '1', '3', 'displayText'       ) : "Gantt", 
					( '1', '3', 'icon'              ) : "aimms-align-left", 
					( '1', '3', 'pageId'            ) : "gantt", 
					( '1', '3', 'tooltip'           ) : "Shows a Gantt chart widget to schedule some tasks", 
					( '1', '3', 'workflowPageState' ) : "Active", 
					( '1', '3', 'pageDataState'     ) : "", 
					( '1', '3', 'redirectPageId'    ) : "home" 
				
				
				
				}
			}
		}
		StringParameter sp_wwwStatusBar {
			IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
			Definition: {
				{
					( '1', 'header'    ) : "",
					( '1', 'icon'      ) : "aimms-glass", 
					( '1', 'color'     ) : "red", 
					( '1', 'text'      ) : "Watch WebUI Widgets 1.0 using AIMMS 4.83",
					( '1', 'tooltip'   ) : "",
					( '1', 'procedure' ) : "",
					( '1', 'state'     ) : "Inactive"
				}
			}
		}
		Set s_okCancel {
			Definition: data { OK, Cancel };
		}
	}
	Section Map_Widget_section {
		DeclarationSection WebUI_Page_and_Widget_support {
			StringParameter sp_mapSidePanel {
				IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
				Definition: {
					{
					
						('1', 'displayText' ) : "Control",
						('1', 'pageId'      ) : "map-config-panel",
						('1', 'tooltip'     ) : "",
						('1', 'icon'        ) : "",
						('1', 'iconcolor'   ) : "",
						('1', 'state'       ) : "Active",
					
						('2', 'displayText' ) : "Story",
						('2', 'pageId'      ) : "map-explain-panel",
						('2', 'tooltip'     ) : "",
						('2', 'icon'        ) : "",
						('2', 'iconcolor'   ) : "",
						('2', 'state'       ) : "Active"
					
					}
				}
			}
			StringParameter sp_locationIcon {
				IndexDomain: i_loc;
				Definition: {
					if i_loc in s_sources then
						"aimms-factory"
					elseif i_loc in s_destinations then
						"aimms-store"
					else
						"aimms-width"
					endif ;
				}
			}
			ElementParameter ep_selectedLocation {
				Range: s_locations;
				InitialData: '';
			}
			StringParameter sp_mapWidgetActions {
				IndexDomain: (webui::indexPageExtension,webui::indexWidgetActionSpec);
				Definition: {
					{
					
						('1', 'displaytext' ) : "Initialize", 
						('1', 'icon'        ) : "aimms-broom", 
						('1', 'procedure'   ) : "pr_mapInit", 
						('1', 'state'       ) : "Active", 
					
						('2', 'displaytext' ) : "Solve", 
						('2', 'icon'        ) : "aimms-spinner9", 
						('2', 'procedure'   ) : "pr_mapSolve", 
						('2', 'state'       ) : "Active", 
					
						('3', 'displaytext' ) : "Edit", 
						('3', 'icon'        ) : "aimms-quill3", 
						('3', 'procedure'   ) : "pr_mapEdit", 
						('3', 'state'       ) : "Hidden"
					
					}
				}
			}
			Parameter bp_showConnections {
				Range: binary;
				InitialData: 1;
			}
			Parameter bp_hideConnections {
				Range: binary;
				Definition: 1 - bp_showConnections;
			}
		}
		DeclarationSection Data_for_the_map_widget {
			Set s_locations {
				Index: i_loc, i_locFrom, i_locTo;
				webui::TooltipIdentifier: ;
			}
			Parameter p_noLocations {
				Definition: card( s_locations );
			}
			Parameter p_noSourceLocations {
				InitialData: 3;
			}
			Parameter p_noDestinationLocations {
				InitialData: 7;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
			}
			Parameter p_locationSizeLower {
				InitialData: 2;
			}
			Parameter p_locationSizeUpper {
				Definition: max( p_capDepot, p_capProduction );
			}
			Parameter p_locationSize {
				IndexDomain: i_loc;
				Range: nonnegative;
				webui::AnnotationsIdentifier: sp_locationAnnotation;
				webui::TooltipIdentifier: sp_locationTooltip;
			}
			Set s_sources {
				SubsetOf: s_locations;
				Index: i_locSource;
				Definition: {
					{ i_loc | ord(i_loc) <= p_noSourceLocations }
				}
			}
			Set s_intermediate {
				SubsetOf: s_locations;
				Index: i_locIntermediate;
				Definition: {
					{ i_loc | ( ord(i_loc) > p_noSourceLocations ) and ( ord(i_loc) <= p_noLocations - p_noDestinationLocations ) }
				}
			}
			Set s_destinations {
				SubsetOf: s_locations;
				Index: i_locDestination;
				Definition: {
					{ i_loc | ord(i_loc) > p_noLocations - p_noDestinationLocations }
				}
			}
			Parameter p_dist {
				IndexDomain: (i_locFrom,i_locTo);
				Definition: {
					! Formula also present on http://www.movable-type.co.uk/scripts/latlong.html section Spherical Law of Cosines.
					!calculate distance from haversine formulas
					 ((6371.0 )*arccos[cos(radians(90 - P_latitude(i_locFrom)))*
					                   cos(radians(90 - P_latitude(i_locTo))) 
					               + 
						           sin(radians(90 - P_latitude(i_locFrom)))* 
					                   sin(radians(90 - P_latitude(i_locTo)))*
					                   cos(radians(p_longitude(i_locFrom)-p_longitude(i_locTo)))
					              ] )  ;
				}
			}
			Set s_nearIntermediates {
				IndexDomain: i_loc;
				SubsetOf: s_locations;
				OrderBy: user;
				Definition: {
					Nbest( i_locIntermediate, -p_dist( i_loc, i_locIntermediate ), 
						if i_loc in s_sources then 3 else 2 endif )
				}
			}
			Parameter bp_arcHelp {
				IndexDomain: (i_locFrom,i_locTo);
				Range: binary;
				Definition: {
					1 $ ( ( i_locTo in s_nearIntermediates( i_locFrom ) ) and 1 )
					!( ( i_locFrom in s_sources ) or ( i_locFrom in s_destinations ) ) )
				}
			}
			Parameter bp_connections {
				IndexDomain: (i_locFrom,i_locTo);
				Range: binary;
				Definition: {
					( ( i_locFrom <> i_locTo                                             ) and
					  ( bp_arcHelp(i_locFrom, i_locTo) or bp_arcHelp(i_locTo, i_locFrom) ) and
					  ( ( ord(i_locFrom ) < ord(i_locTo)                            ) or 
					    ( i_locFrom in s_intermediate and i_locTo in s_Intermediate )    )      )
				}
			}
			Parameter p_arc {
				IndexDomain: (i_locFrom,i_locTo);
				Definition: {
					if bp_showConnections then
						bp_connections(i_locFrom, i_locTo)
					else
						v_flow(i_locFrom, i_locTo)
					endif
				}
			}
			Parameter p_totUnmetDemand {
				Definition: sum( i_locDestination, v_unmetDemand(i_locDestination) );
			}
			StringParameter sp_locationType {
				IndexDomain: i_loc;
				Definition: {
					if i_loc in s_sources then
						"distillation"
					elseif i_loc in s_intermediate then
						"pumping"
					else
						"bottling"
					endif
				}
			}
			StringParameter sp_locationAnnotation {
				IndexDomain: i_loc;
				Definition: {
					if ( i_loc in s_sources  ) and p_totUnmetDemand then
						if v_prod(i_loc) = p_locationSize(i_loc) then
							"atproductioncapacity"
						else
							""
						endif
					elseif ( i_loc in s_intermediate ) and p_totUnmetDemand then
						if v_depotInflow(i_loc) = p_locationSize(i_loc) then
							"atpumpingcapacity"
						else
							""
						endif
					else
						if v_unmetDemand(i_loc) then
							"unmetdemand"
						else
							""
						endif
					endif
				}
			}
			StringParameter sp_locationTooltip {
				IndexDomain: i_loc;
				Definition: {
					"<div align=\"left\">"  +
					"<Table>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Name : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                formatString("%e", i_loc) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Type : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_locationType( i_loc ) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> " + 
					                                if i_loc in s_sources then
					                                	"Capacity"
					                                elseif i_loc in s_intermediate then 
					                                	"Capacity"
					                                else
					                                	"Demand"
					                                endif
					                                + " : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                p_locationSize(i_loc) +
					                "</TD>" +
					        "</TR>"  +
					        if sum( i_locFrom, v_prod(i_locFrom ) ) then
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> " + 
					                                if i_loc in s_sources then
					                                	"Production"
					                                elseif i_loc in s_intermediate then 
					                                	"Flow"
					                                else
					                                	"Unmet demand"
					                                endif
					                                + " : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                if i_loc in s_sources then
					                                	v_prod(i_loc)
					                                elseif i_loc in s_intermediate then 
					                                	sum( i_locFrom, v_flow(i_locFrom, i_loc) )
					                                else
					                                	v_unmetDemand(i_loc)
					                                endif +
					                "</TD>" +
					        "</TR>"  
					        else "" endif 
					        +
					"</Table>"
				}
			}
			Parameter p_relativeSize {
				InitialData: 40;
			}
		}
		Procedure pr_openPageMap {
			Body: {
				pr_readMapData();
				if not ep_selectedLocation then
					ep_selectedLocation := first( s_locations );
				endif ;
			}
			Comment: {
				"This procedure is run upon opening page \"mapDemo\"
				It will initialize the data shown on that page."
			}
		}
		Procedure pr_readMapData {
			Body: {
				empty s_locations ;
				
				dex::AddMapping(
					mappingName :  "fewCitiesLatLongCSV", 
					mappingFile :  "mappings/fewCitiesLatLongCSV.xml") ;
				
				dex::ReadFromFile(
					dataFile         :  "data/twentyGermanCities.csv", 
					mappingName      :  "fewCitiesLatLongCSV", 
					emptyIdentifiers :  1, 
					emptySets        :  1, 
					resetCounters    :  1);
				
				pr_initSizes();
			}
		}
		Procedure pr_initSizes {
			Body: {
				
				p_locationSize(i_locSource) !| ( p_locationSize(i_locSource) = 0 ) 
					:= p_capProduction ;
				
				p_locationSize(i_locDestination) ! | ( p_locationSize(i_locDestination) = 0 ) 
					:= round( uniform( p_locationSizeLower /* + ( p_locationSizeUpper - p_locationSizeLower ) / 4 */, p_locationSizeUpper - ( p_locationSizeUpper - p_locationSizeLower ) / 3 ) );
				
				p_locationSize(i_locIntermediate) ! | ( p_locationSize(i_locIntermediate) = 0 ) 
					:= p_capDepot ;
				
				empty s_mapDemoVariables  ;
				
				bp_showConnections := 1 ; ! Now showing connections instead of flows.
			}
		}
		Procedure pr_mapInit {
			Body: {
				
				pr_initSizes();
			}
		}
		Procedure pr_mapSolve {
			Body: {
				pr_solveMapDemo();
			}
		}
		Procedure pr_mapEdit;
		Section map_demo_math_model {
			Parameter p_productionUnitCost {
				InitialData: 1;
			}
			Parameter p_transportationUnitCost {
				InitialData: 1;
			}
			Parameter p_penaltyUnmetDemand {
				InitialData: 1000;
			}
			Parameter p_capPipe {
				InitialData: 10;
			}
			Parameter p_capDepot {
				InitialData: 30;
			}
			Parameter p_capProduction {
				InitialData: 40;
			}
			Variable v_flow {
				IndexDomain: (i_locFrom,i_locTo) | bp_connections(i_locFrom, i_locTo);
				Range: [0, p_capPipe];
			}
			Variable v_prod {
				IndexDomain: (i_loc) | i_loc in s_sources;
				Range: [0, p_locationSize(i_loc)];
			}
			Variable v_cost {
				Range: free;
				Definition: {
					sum( i_loc, p_productionUnitCost * v_prod(i_loc) )
					+
					sum( (i_locFrom, i_locTo), p_transportationUnitCost * v_flow(i_locFrom, i_locTo) )
					+
					sum( i_locTo, p_penaltyUnmetDemand * v_unmetDemand(i_locTo) )
				}
			}
			Variable v_depotInflow {
				IndexDomain: i_loc | i_loc in s_intermediate;
				Range: [0, p_locationSize(i_loc)];
				Definition: sum( i_locFrom, v_flow(i_locFrom, i_loc) );
			}
			Variable v_depotOutflow {
				IndexDomain: i_loc | i_loc in s_intermediate;
				Range: [0, p_locationSize(i_loc)];
				Definition: sum( i_locTo, v_flow(i_loc, i_locTo) );
			}
			Variable v_unmetDemand {
				IndexDomain: i_locTo| ( i_locTo in s_destinations );
				Range: nonnegative;
			}
			Constraint c_meetDemand {
				IndexDomain: i_locTo | ( i_locTo in s_destinations );
				Definition: {
					sum( i_locFrom, v_flow( i_locFrom, i_locTo ) ) + v_unmetDemand( i_locTo ) 
					= 
					p_locationSize( i_locTo )
				}
			}
			Constraint c_balancePumps {
				IndexDomain: i_loc | i_loc in s_intermediate;
				Definition: {
					v_depotInflow(i_loc)
					=
					v_depotOutflow(i_loc)
				}
			}
			Constraint c_supplyNeeded {
				IndexDomain: i_loc | i_loc in s_sources;
				Definition: sum( i_locTo, v_flow(i_loc, i_locTo) ) = v_prod( i_loc );
			}
			Set s_mapDemoVariables {
				SubsetOf: AllVariables;
				Definition: map_demo_math_model * AllVariables;
			}
			Set s_mapDemoConstraints {
				SubsetOf: AllConstraints;
				Definition: map_demo_math_model * AllConstraints;
			}
			MathematicalProgram mp_mapDemo {
				Objective: v_cost;
				Direction: minimize;
				Constraints: AllConstraints;
				Variables: AllVariables;
				Type: Automatic;
			}
			Procedure pr_solveMapDemo {
				Body: {
					solve mp_mapDemo ;
					bp_showConnections := 0 ; ! Now showing flows instead of connections.
					
					!p_locationSize(i_loc)| ( i_loc in s_sources ) :=
					!	if v_prod(i_loc) < p_locationSizeLower then 
					!		p_locationSizeLower
					!	elseif v_prod(i_loc) > p_locationSizeUpper then 
					!		p_locationSizeUpper
					!	else
					!		v_prod(i_loc)
					!	endif ;
					!
					!p_locationSize(i_loc)| ( i_loc in s_intermediate ) :=
					!	if v_depotInflow(i_loc) < p_locationSizeLower then 
					!		p_locationSizeLower
					!	elseif v_depotInflow(i_loc) > p_locationSizeUpper then 
					!		p_locationSizeUpper
					!	else
					!		v_depotInflow(i_loc)
					!	endif ;
					!
				}
			}
		}
		Section item_actions_locations {
			StringParameter sp_mapLocationItemActions {
				IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
				Definition: {
					{
						('p_locationSize', '1', 'displaytext') : formatString("Increase %s %e by 1", if ep_selectedLocation in s_destinations then "demand" else "capacity" endif, ep_selectedLocation),
						('p_locationSize', '1', 'icon'       ) : "aimms-volume-increase2",
						('p_locationSize', '1', 'procedure'  ) : "pr_locSizeIncrease1",
						('p_locationSize', '1', 'state'      ) : "Active",
					
						('p_locationSize', '2', 'displaytext') : formatString("Increase %s %e by 5", if ep_selectedLocation in s_destinations then "demand" else "capacity" endif, ep_selectedLocation),
						('p_locationSize', '2', 'icon'       ) : "aimms-volume-increase",
						('p_locationSize', '2', 'procedure'  ) : "pr_locSizeIncrease5",
						('p_locationSize', '2', 'state'      ) : "Active",
					
						('p_locationSize', '3', 'displaytext') : formatString("Decrease %s %e by 1", if ep_selectedLocation in s_destinations then "demand" else "capacity" endif, ep_selectedLocation),
						('p_locationSize', '3', 'icon'       ) : "aimms-volume-decrease2",
						('p_locationSize', '3', 'procedure'  ) : "pr_locSizeDecrease1",
						('p_locationSize', '3', 'state'      ) : "Active",
					
						('p_locationSize', '4', 'displaytext') : formatString("Decrease %s %e by 5", if ep_selectedLocation in s_destinations then "demand" else "capacity" endif, ep_selectedLocation),
						('p_locationSize', '4', 'icon'       ) : "aimms-volume-decrease",
						('p_locationSize', '4', 'procedure'  ) : "pr_locSizeDecrease5",
						('p_locationSize', '4', 'state'      ) : "Active",
					
						('p_locationSize', '5', 'displaytext') : formatString("Edit %e", ep_selectedLocation),
						('p_locationSize', '5', 'icon'       ) : "aimms-quill",
						('p_locationSize', '5', 'procedure'  ) : "pr_locSizeDetails",
						('p_locationSize', '5', 'state'      ) : "Active"
					}
				}
			}
			Procedure pr_locSizeIncrease1 {
				Body: {
					! The affected node is selected via the store focus, see https://documentation.aimms.com/webui/map-widget.html#store-focus-hover-and-select-for-nodes
					p_ub := if ep_selectedLocation in s_sources then 2 * p_capProduction
					        elseif ep_selectedLocation in s_intermediate then 2 * p_capDepot
					        else p_capProduction endif ;
					if p_locationSize(ep_selectedLocation) + 1 > p_ub then
						raise warning 
							"Exceeding upper bound " + p_ub + 
							" at location size " + ep_selectedLocation ;
						p_locationSize(ep_selectedLocation) := p_ub ;
					else
						p_locationSize(ep_selectedLocation) += 1 ;
					endif ;
				}
				Parameter p_ub;
			}
			Procedure pr_locSizeIncrease5 {
				Body: {
					! The affected node is selected via the store focus, see https://documentation.aimms.com/webui/map-widget.html#store-focus-hover-and-select-for-nodes
					p_ub := if ep_selectedLocation in s_sources then 2 * p_capProduction
					        elseif ep_selectedLocation in s_intermediate then 2 * p_capDepot
					        else p_capProduction endif ;
					if p_locationSize(ep_selectedLocation) + 5 > p_ub then
						raise warning 
							"Exceeding upper bound " + p_ub + 
							" at location size " + ep_selectedLocation ;
						p_locationSize(ep_selectedLocation) := p_ub ;
					else
						p_locationSize(ep_selectedLocation) += 5 ;
					endif ;
				}
				Parameter p_ub;
			}
			Procedure pr_locSizeDecrease1 {
				Body: {
					! The affected node is selected via the store focus, see https://documentation.aimms.com/webui/map-widget.html#store-focus-hover-and-select-for-nodes
					p_lb := 2 ;
					if p_locationSize(ep_selectedLocation) - 1 < p_lb then
						raise warning 
							"Exceeding lower bound " + p_lb + 
							" at location size " + ep_selectedLocation ;
						p_locationSize(ep_selectedLocation) := p_lb ;
					else
						p_locationSize(ep_selectedLocation) -= 1 ;
					endif ;
				}
				Parameter p_lb;
			}
			Procedure pr_locSizeDecrease5 {
				Body: {
					! The affected node is selected via the store focus, see https://documentation.aimms.com/webui/map-widget.html#store-focus-hover-and-select-for-nodes
					p_lb := 2 ;
					if p_locationSize(ep_selectedLocation) - 5 < p_lb then
						raise warning 
							"Exceeding lower bound " + p_lb + 
							" at location size " + ep_selectedLocation ;
						p_locationSize(ep_selectedLocation) := p_lb ;
					else
						p_locationSize(ep_selectedLocation) -= 5 ;
					endif ;
				}
				Parameter p_lb;
			}
			Section location_detail_dialog_page {
				Set s_inputOutput {
					Index: i_io;
					Definition: data { input, output };
				}
				Set s_connectedLocations {
					SubsetOf: s_locations;
					Index: i_locConnected;
					Definition: {
						{ i_loc | p_arc(ep_selectedLocation, i_loc) or p_arc(i_loc, ep_selectedLocation) }
					}
					Comment: "Locations connected to ep_selectedLocation";
				}
				Parameter p_inputOutputData {
					IndexDomain: (i_loc,i_io);
					Definition: {
						if i_io = 'input' then
							v_flow(i_loc, ep_selectedLocation)
						else
							v_flow(ep_selectedLocation, i_loc)
						endif
					}
				}
				StringParameter sp_locationDetailIOtitle {
					Definition: formatString("Locations connected to %e", ep_selectedLocation);
				}
				Procedure pr_locSizeDetails {
					Body: {
						!raise error "todo" ;
						! page-id: location-detail
						CurrentInputs -= data { p_inputOutputData };
						webui::OpenDialogPage(
							pageId  :  'location-detail', 
							title   :  
								formatString("Details for %s \"%e\"", 
									sp_locationType(ep_selectedLocation),
									ep_selectedLocation ),
							actions :  s_okCancel, 
							onDone  :  'pr_completeLocSizeDetails');
					}
				}
				Procedure pr_completeLocSizeDetails {
					Arguments: (sp_answer);
					StringParameter sp_answer {
						Property: Input;
					}
				}
			}
		}
	}
	Section Gantt_Widget_section {
		Section TimeRepresentation {
			DeclarationSection Control_Declarations {
				Parameter numberOfDaysInCalendar {
					InitialData: 7;
				}
				StringParameter fmtHourCal {
					Definition: "%c%y-%m-%d %H";
				}
				StringParameter begHourCal {
					InitialData: "2016-05-09 00";
				}
			}
			DeclarationSection Actual_Calendar_declaration {
				StringParameter endHourCal {
					Definition: {
						MomentToString(
							Format        :  fmtHourCal,
							unit          :  [hour],
							ReferenceDate :  begHourCal,
							Elapsed       :  (numberOfDaysInCalendar*24) [hour])
					}
				}
				Calendar HourCalendar {
					Index: i_hc, i_hc1, i_hc2;
					Unit: hour;
					BeginDate: begHourCal;
					EndDate: endHourCal;
					TimeslotFormat: fmtHourCal;
				}
				ElementParameter startHour {
					Range: HourCalendar;
					Definition: first(HourCalendar);
				}
				ElementParameter lastHour {
					Range: HourCalendar;
					Definition: last(HourCalendar);
				}
				Parameter timeZoneOffsetNeededForWebUIGanttCharts {
					Unit: minute;
					Definition: TimeZoneOffSet( 'UTC', 'LocalDST', UseDST: 1 );
				}
				Parameter granulWinUICal {
					InitialData: 3;
				}
			}
		}
		Section Input_Data {
			DeclarationSection Input_Sets {
				Set S_AvailableLines {
					Index: i_al;
				}
				Set S_OrderNumbers {
					Index: i_o;
					webui::ElementTextIdentifier: s_productNames;
				}
				StringParameter sp_orderName {
					IndexDomain: i_o;
					Definition: formatString("%e",i_o);
				}
				Set S_ProductTypes {
					Index: i_pt;
					Definition: data { small, medium, large };
				}
				Set s_productNames {
					Index: i_pn;
				}
			}
			DeclarationSection Input_Parameters {
				ElementParameter EP_ProductType {
					IndexDomain: i_pn;
					Range: S_ProductTypes;
					InitialData: data {};
				}
				Parameter P_Capac {
					IndexDomain: (i_al,i_pt);
					Unit: lpu/hour;
					Comment: "For each available line";
				}
				Parameter P_OrderQuantity {
					IndexDomain: i_o;
					Unit: lpu;
					InitialData: data {};
				}
				ElementParameter EP_OrderProduct {
					IndexDomain: i_o;
					Range: s_productNames;
					InitialData: data {};
				}
				ElementParameter EP_OrderDeliveryDate {
					IndexDomain: (i_o);
					Range: HourCalendar;
					InitialData: data {};
				}
				Parameter bp_orderScheduledByHuman {
					IndexDomain: i_o;
					Range: binary;
					InitialData: data {};
				}
				ElementParameter ep_orderProductionLine {
					IndexDomain: i_o;
					Range: S_AvailableLines;
					InitialData: data {};
				}
				ElementParameter ep_orderStartDate {
					IndexDomain: i_o;
					Range: HourCalendar;
					InitialData: data {};
				}
			}
			DeclarationSection Input_Parameter_copies {
				ElementParameter EP_D_OrderProduct {
					IndexDomain: i_o;
					Range: s_productNames;
					Definition: EP_OrderProduct(i_o);
				}
				ElementParameter EP_OrderProductType {
					IndexDomain: i_o;
					Range: S_ProductTypes;
					Definition: EP_ProductType( EP_OrderProduct( i_o ) );
				}
				Parameter P_D_OrderQuantity {
					IndexDomain: i_o;
					Unit: lpu;
					Definition: P_OrderQuantity(i_o);
				}
				ElementParameter EP_D_OrderDeliveryDate {
					IndexDomain: (i_o);
					Range: HourCalendar;
					Definition: EP_OrderDeliveryDate(i_o);
				}
			}
			DeclarationSection Input_Controls {
				ElementParameter ep_selectedOrder {
					Range: S_OrderNumbers;
				}
				ElementParameter e_selectedStartTime {
					Range: HourCalendar;
				}
				ElementParameter e_selectedProductionLine {
					Range: S_AvailableLines;
				}
			}
		}
		DeclarationSection Shared_UoM {
			Quantity LocProductUnit {
				BaseUnit: lpu;
			}
			Quantity SI_Unitless {
				BaseUnit: -;
				Conversions: %->- : #-># / 100;
				Comment: "Expresses a dimensionless value.";
			}
		}
		Section WebUI_declarations {
			Set AllPublicIdentifiers {
				SubsetOf: AllIdentifiers;
				Definition: {
					( Main_Watch_WebUI_Widgets ) *
					( AllSets + AllParameters + AllVariables + AllConstraints + AllProcedures )
				}
			}
			StringParameter sp_ganttPageSecondaryActions {
				IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
				Definition: {
					{
						( '1', 'displaytext' ) : "Optimize",
						( '1', 'icon'        ) : "aimms-pacman",
						( '1', 'procedure'   ) : "SolveMixedIntegerProgrammingProblem",
						( '1', 'state'       ) : "Active"
					}
				}
			}
			StringParameter sp_ganttChartSidePanel {
				IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
				Definition: {
					{
						('1', 'displayText' ) : "Control",
						('1', 'pageId'      ) : "gantt-config-panel",
						('1', 'tooltip'     ) : "",
						('1', 'icon'        ) : "",
						('1', 'iconcolor'   ) : "",
						('1', 'state'       ) : "Active",
					
						('2', 'displayText' ) : "Story",
						('2', 'pageId'      ) : "gantt-explain-panel",
						('2', 'tooltip'     ) : "",
						('2', 'icon'        ) : "",
						('2', 'iconcolor'   ) : "",
						('2', 'state'       ) : "Active"
					}
				}
			}
			Section Gantt_Chart_Handling {
				Section item_actions_gantt_chart {
					StringParameter sp_ganttItemActions {
						IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
						Definition: {
							{
								('p_WebUIGNTDuration', '1', 'displaytext') : "Move to front",
								('p_WebUIGNTDuration', '1', 'icon'       ) : "aimms-first",
								('p_WebUIGNTDuration', '1', 'procedure'  ) : "pr_moveToFront",
								('p_WebUIGNTDuration', '1', 'state'      ) : if bp_orderScheduledByHuman( ep_selectedOrder ) then "Active" else "Inactive" endif,
							
								('p_WebUIGNTDuration', '2', 'displaytext') : "Delay until deadline",
								('p_WebUIGNTDuration', '2', 'icon'       ) : "aimms-last",
								('p_WebUIGNTDuration', '2', 'procedure'  ) : "pr_delayUntilDeadline",
								('p_WebUIGNTDuration', '2', 'state'      ) : if bp_orderScheduledByHuman( ep_selectedOrder ) then "Active" else "Inactive" endif,
							
								('p_WebUIGNTDuration', '3', 'displaytext') : "Allow scheduling by living creature",
								('p_WebUIGNTDuration', '3', 'icon'       ) : "aimms-grab",
								('p_WebUIGNTDuration', '3', 'procedure'  ) : "pr_scheduleByLivingCreature",
								('p_WebUIGNTDuration', '3', 'state'      ) : if not bp_orderScheduledByHuman( ep_selectedOrder ) then "Active" else "Inactive" endif,
							
								('p_WebUIGNTDuration', '4', 'displaytext') : "Allow scheduling by optimization algorithm",
								('p_WebUIGNTDuration', '4', 'icon'       ) : "aimms-music",
								('p_WebUIGNTDuration', '4', 'procedure'  ) : "pr_scheduleByOptimizationAlgorithm",
								('p_WebUIGNTDuration', '4', 'state'      ) : if bp_orderScheduledByHuman( ep_selectedOrder ) then "Active" else "Inactive" endif,
							
								('p_WebUIGNTDuration', '5', 'displaytext') : "Delete",
								('p_WebUIGNTDuration', '5', 'icon'       ) : "aimms-bin",
								('p_WebUIGNTDuration', '5', 'procedure'  ) : "pr_deleteJob",
								('p_WebUIGNTDuration', '5', 'state'      ) : "Active",
							
								('p_WebUIGNTDuration', '6', 'displaytext') : "Edit",
								('p_WebUIGNTDuration', '6', 'icon'       ) : "aimms-quill",
								('p_WebUIGNTDuration', '6', 'procedure'  ) : "pr_editJob",
								('p_WebUIGNTDuration', '6', 'state'      ) : "Active"
							}
						}
					}
					StringParameter sp_scalarWidgetDialogPageTitle {
						Definition: {
							formatString("Edit %e", ep_selectedOrder );
						}
					}
					Procedure pr_moveToFront {
						Body: {
							if ep_selectedOrder and bp_orderScheduledByHuman( ep_selectedOrder ) then
							
							endif ;
						}
					}
					Procedure pr_delayUntilDeadline;
					Procedure pr_scheduleByLivingCreature {
						Body: {
							if ep_selectedOrder then
								bp_orderScheduledByHuman( ep_selectedOrder ) := 1 ;
							endif ;
						}
					}
					Procedure pr_scheduleByOptimizationAlgorithm {
						Body: {
							if ep_selectedOrder then
								bp_orderScheduledByHuman( ep_selectedOrder ) := 0 ;
							endif ;
						}
					}
					Procedure pr_deleteJob;
					Procedure pr_editJob;
				}
				Procedure pr_UponChange_WebUIGNTDuration;
				Procedure pr_UponChange_WebUIGNTStartTime {
					Body: {
						ep_modifiedOrder := first( i_o | not forall( i_al, 
							p_hist_WebUIGNTStartTime(i_al, i_o) = p_WebUIGNTStartTime(i_al, i_o) ) );
						if ep_modifiedOrder then
						
							block ! With item actions, the following is no longer needed.
							! If we move an order, we toggle the fixed status 
							! which implies that an order may become free!
							! bp_orderScheduledManually( ep_modifiedOrder ) := 1 - bp_orderScheduledManually( ep_modifiedOrder );
							endblock ;
						
							! set EP_OrderStartDate(i_o) and EP_OrderProductionLine(i_o)
							ep_ModifiedProductionLine := first( i_al |
								p_hist_WebUIGNTStartTime(i_al, ep_modifiedOrder) <> p_WebUIGNTStartTime(i_al, ep_modifiedOrder) );
							ep_orderStartDate(ep_modifiedOrder) :=
								MomentToTimeSlot(
									Calendar      :  HourCalendar, 
									ReferenceDate :  startHour, 
									Elapsed       :  p_WebUIGNTStartTime(ep_ModifiedProductionLine, ep_modifiedOrder) - timeZoneOffsetNeededForWebUIGanttCharts );
						 	p_hist_WebUIGNTStartTime(i_al, ep_modifiedOrder) := p_WebUIGNTStartTime(i_al, ep_modifiedOrder);
						endif ;
					}
					ElementParameter ep_ModifiedProductionLine {
						Range: S_AvailableLines;
					}
					ElementParameter ep_modifiedOrder {
						Range: S_OrderNumbers;
					}
				}
				DeclarationSection WebUI_Gantt_Chart_Declarations {
					StringParameter begHourCalWebUI {
						Definition: {
							MomentToString(
								Format        :  "%c%y-%m-%d %H:00", 
								unit          :  [hour], 
								ReferenceDate :  begHourCal, 
								Elapsed       :  timeZoneOffsetNeededForWebUIGanttCharts)
						}
					}
					Parameter p_WebUIGNTStartTime {
						IndexDomain: (i_al,i_o);
						Unit: hour;
						webui::UponChangeProcedure: pr_UponChange_WebUIGNTStartTime;
					}
					Parameter p_hist_WebUIGNTStartTime {
						IndexDomain: (i_al,i_o);
						Unit: hour;
					}
					Parameter p_WebUIGNTDuration {
						IndexDomain: (i_al,i_o);
						Unit: hour;
						InitialData: data {};
						webui::AnnotationsIdentifier: WebUIGNTDuration_anno;
						webui::ItemTextIdentifier: sp_jobText;
						webui::TooltipIdentifier: sp_jobTooltip;
						webui::UponChangeProcedure: pr_UponChange_WebUIGNTDuration;
					}
					StringParameter WebUIGNTDuration_anno {
						IndexDomain: (i_al,i_o)|p_WebUIGNTDuration(i_al,i_o);
						Definition: {
							if bp_orderScheduledByHuman(i_o) then
								"manualJob"
							else
								"freeJob"
							endif
						}
					}
					Parameter WebUIGNTViewStart;
					Parameter WebUIGNTViewEnd;
					StringParameter sp_jobText {
						IndexDomain: (i_al,i_o)|p_WebUIGNTDuration(i_al, i_o);
						Definition: {
							if p_WebUIGNTDuration(i_al, i_o) < 1[hour] then
								""
							elseif p_WebUIGNTDuration(i_al, i_o) < 3[hour] then
								formatString("o %e",i_o)
							elseif p_WebUIGNTDuration(i_al, i_o) < 8[hour] then
								formatString("order %e",i_o)
							else
								formatString("order %e: %e %i lpu",
									i_o, EP_OrderProductType(i_o),
									P_OrderQuantity(i_o))
							endif
						}
					}
					StringParameter sp_jobTooltip {
						IndexDomain: (i_al,i_o)|p_WebUIGNTDuration(i_al, i_o);
						Definition: {
							"<div align=\"left\">"  +
							"<Table>" +
							        "<TR>"  +
							                "<TD>"  +
							                        "<B> order : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        formatString("%e", i_o) +
							                "</TD>" +
							                "<TD>"  +
							                        "<B> " + 
							                             	"Start"
							                        + " : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        formatString("%e",ep_orderStartDate(i_o)) +
							                "</TD>" +
							        "</TR>" 
							        +
							        "<TR>"  +
							                "<TD>"  +
							                        "<B> Product : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        EP_OrderProduct( i_o ) +
							                "</TD>" +
							                "<TD>"  +
							                        "<B> " +                                 
							                              	"Line "
							                        + " : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        formatString("%e",ep_orderProductionLine(i_o)) +
							                "</TD>" +
							        "</TR>" 
							        +
							        "<TR>"  +
							                "<TD>"  +
							                        "<B> " + 
							                              	"Amount"
							                        + " : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        P_OrderQuantity(i_o) +
							                "</TD>" +
							                "<TD>"  +
							                        "<B> " + 
							                               	"Duration "
							                        + " : </B>" +
							                "</TD>" +
							                "<TD>"  +
							                        formatString("%i",p_WebUIGNTDuration(i_al,i_o)) +
							                "</TD>" +
							        "</TR>"  
							        +
							"</Table>"
						}
					}
				}
				DeclarationSection WebUI_Order_Info_Identifiers {
					Parameter BP_D_OrderScheduledManuallyUsable {
						IndexDomain: i_o;
						Definition: bp_orderScheduledByHuman(i_o) and ep_orderStartDate(i_o) and ep_orderProductionLine(i_o);
					}
				}
				Procedure PrepWebUIGanttChartIdentifiers {
					Body: {
						empty p_WebUIGNTStartTime ;
						
						p_WebUIGNTStartTime(i_al, i_o)|startTimeActivity(i_al, i_o) :=
							TimeslotToMoment(
								Calendar      :  HourCalendar,
								ReferenceDate :  startHour,
								Timeslot      :  startTimeActivity(i_al, i_o)) + timeZoneOffsetNeededForWebUIGanttCharts ;
						p_hist_WebUIGNTStartTime(i_al, i_o) := p_WebUIGNTStartTime(i_al, i_o);
						
						p_WebUIGNTDuration(i_al, i_o) := durationActivity(i_al, i_o);
						
						!CurrentInputs -= data { 'p_WebUIGNTDuration' } ;
						
						PrepWebUIOrderInfoFromSolution();
					}
				}
				Procedure PrepWebUIOrderInfoFromSolution {
					Body: {
						for i_al do 
							ep_orderStartDate(i_o) | startTimeActivity(i_al, i_o)      := startTimeActivity(i_al, i_o);
							ep_orderProductionLine(i_o) | startTimeActivity(i_al, i_o) := i_al ;
						endfor ;
					}
				}
				Procedure uponModificationOrderInfo {
					Body: {
						! when BP_OrderScheduledManually(i_o)
						!    then 
						!       set WebUIGNTStartTime, 
						!       set startTimeActivity (WinUI)
						!       Fixed activity: ProduceOrderOnLine (See listenTo constraints)
						!       Fixed variable: StartProductionOnProductionLine  (See listenTo constraints)
						!    using
						!	EP_OrderStartDate
						!       EP_OrderProductionLine
						
						! when not BP_OrderScheduledManually(i_o)
						!      ---
						!    compute
						!	EP_OrderStartDate
						!       EP_OrderProductionLine
						!	WebUIGNTStartTime
						!	startTimeActivity
						!    from
						!       solution CP or MIP.
						
						! Nb. BP_D_OrderScheduledManuallyUsable is the same as BP_OrderScheduledManually 
						!     but only true when start date and line have been set; manual scheduling is
						!     not relevant if start data or production line have not been set for that order.
						
						! DebuggerBreakpoint();
						
						p_WebUIGNTStartTime(i_al, i_o) | BP_D_OrderScheduledManuallyUsable(i_o)  				 
							:= if i_al = ep_orderProductionLine(i_o) then 
								TimeslotToMoment(
									Calendar      :  HourCalendar,
									ReferenceDate :  startHour,
									Timeslot      :  ep_orderStartDate(i_o)) + timeZoneOffsetNeededForWebUIGanttCharts  
							   else
							   	0[hour]
							   endif ;	   
						p_WebUIGNTDuration(i_al, i_o) | BP_D_OrderScheduledManuallyUsable(i_o)  				 
							:= if i_al = ep_orderProductionLine(i_o) then 
								ActivityLength(i_al, i_o)
							   else
							   	0
							   endif ;
						
						startTimeActivity(i_al, i_o) | BP_D_OrderScheduledManuallyUsable(i_o)  				 
							:= if i_al = ep_orderProductionLine(i_o) then 
								ep_orderStartDate(i_o)
							   else
							   	startHour
							   endif ;
						durationActivity(i_al, i_o) | BP_D_OrderScheduledManuallyUsable(i_o)  				 
							:= if i_al = ep_orderProductionLine(i_o) then 
								ActivityLength(i_al, i_o)
							   else
							   	0
							   endif ;
					}
				}
			}
		}
		Section Scheduling_Solution_Procedures {
			Procedure SetInterruptFlag {
				Body: {
					InterruptFlag := 1 ;
				}
			}
			DeclarationSection Scheduling_Support_Identifiers {
				Parameter time_limit_in_seconds {
					InitialData: 60;
				}
				Parameter ActivityLength {
					IndexDomain: (i_al,i_o);
					Unit: hour;
					Definition: Ceil( P_OrderQuantity(i_o) / P_Capac(i_al, EP_ProductType( EP_OrderProduct( i_o ) ) ) );
				}
				Parameter ActivityLengthM1 {
					IndexDomain: (i_al,i_o);
					Unit: hour;
					Definition: ActivityLength(i_al, i_o)-1[hour];
				}
				Parameter InterruptFlag {
					InitialData: 0;
				}
			}
			DeclarationSection Scheduing_Common_Variables_and_Constraints {
				Variable Makespan {
					Range: free;
					Unit: hour;
				}
			}
			Section Mixed_Integer_Programming_Scheduling_Model {
				Procedure SolveMixedIntegerProgrammingProblem {
					Body: {
						
						ep_StartNoOverlap(i_al, i_o, i_hc) := i_hc-ActivityLengthM1(i_al, i_o)/1[hour]  ;
						ep_StartNoOverlap(i_al, i_o, i_hc) | ( ep_StartNoOverlap(i_al, i_o, i_hc) = '' ) := startHour ;
						
						!MachineSchedulingMixedIntegerProgrammingFormulation.CallbackNewIncumbent := 'MIP_incumbentCallback' ;
						!MachineSchedulingMixedIntegerProgrammingFormulation.CallbackTime         := 'MIP_TimeCallback' ;
						if pro::PROEndPoint then
							pro::ManagedSessionInputCaseIdentifierSet :=
								AllMathematicalPrograms +
								AllMixedIntegerProgrammingVariables +
								AllMixedIntegerProgrammingConstraints +
								ReferencedIdentifiers( AllMixedIntegerProgrammingVariables, AllAttributeNames, 1) +
								ReferencedIdentifiers( AllMixedIntegerProgrammingConstraints, AllAttributeNames, 1) ;
							DelegateSolveMixedIntegerProgrammingProblem();
						else
							WorkSolveMixedIntegerProgrammingProblem();
						endif ;
						
						! Remove small values (noise) from CPLEX/MIP solution
						SelectProcutionLine(i_al, i_o) | ( SelectProcutionLine(i_al, i_o) and ( abs( SelectProcutionLine(i_al, i_o) <= 0.1 ) ) ) := 0 ;
						StartProductionOnProductionLine(i_al,i_o,i_hc) | ( StartProductionOnProductionLine(i_al,i_o,i_hc) and
						   ( abs( StartProductionOnProductionLine(i_al,i_o,i_hc) ) <= 0.1 ) ) := 0 ;
						
						ComputeMakeSpan;
						
						PrepGanttChartIdentifiersFromMIPSolution ;
					}
				}
				Procedure DelegateSolveMixedIntegerProgrammingProblem {
					Body: {
						if pro::DelegateToServer(
								completionCallback: 'pro::session::LoadResultsCallback',
								waitForCompletion:1) then
							return ;
						endif ;
						WorkSolveMixedIntegerProgrammingProblem();
						pro::ManagedSessionOutputCaseIdentifierSet := AllMixedIntegerProgrammingVariables ;
					}
				}
				Procedure WorkSolveMixedIntegerProgrammingProblem {
					Body: {
						!MachineSchedulingMixedIntegerProgrammingFormulation.CallbackNewIncumbent := 'MIP_incumbentCallback' ;
						!MachineSchedulingMixedIntegerProgrammingFormulation.CallbackTime         := 'MIP_TimeCallback' ;
						solve MachineSchedulingMixedIntegerProgrammingFormulation ; !  where time_limit := time_limit_in_seconds ;
					}
				}
				Procedure MIP_incumbentCallback {
					Body: {
						RetrieveCurrentVariableValues(AllMixedIntegerProgrammingVariables) ;
						ComputeMakeSpan;
						PrepGanttChartIdentifiersFromMIPSolution ;
						PageRefreshAll ;
						if InterruptFlag then
							MachineSchedulingMixedIntegerProgrammingFormulation.CallbackReturnStatus := 'abort';
						endif ;
					}
				}
				Procedure MIP_TimeCallback {
					Body: {
						if InterruptFlag then
							MachineSchedulingMixedIntegerProgrammingFormulation.CallbackReturnStatus := 'abort';
						endif ;
					}
				}
				Procedure PrepGanttChartIdentifiersFromMIPSolution {
					Body: {
						! For WinUI
						empty durationActivity, startTimeActivity ;
						for (i_al, i_o) | SelectProcutionLine(i_al, i_o) do
							for i_hc | StartProductionOnProductionLine(i_al, i_o, i_hc) do
								startTimeActivity(i_al, i_o) :=  i_hc ;
							endfor ;
							durationActivity(i_al, i_o) := ActivityLength(i_al, i_o);
						endfor ;
						
						! For WebUI
						PrepWebUIGanttChartIdentifiers ;
					}
				}
				Procedure ComputeMakeSpan {
					Body: {
						empty ep_jobends ;
						for (i_al,i_o,i_hc) | StartProductionOnProductionLine(i_al,i_o,i_hc) do
							ep_jobEnds(i_al,i_o) := i_hc + ActivityLength(i_al, i_o)/1[hour];
						endfor ;
						ep_LineEnds(i_al) := max( i_o, ep_jobends( i_al, i_o) );
						
						makespan := max( i_al, ep_lineEnds(i_al) - starthour );
					}
					ElementParameter ep_jobends {
						IndexDomain: (i_al,i_o);
						Range: HourCalendar;
					}
				}
				Procedure ReadMachineConfig {
					Body: {
						read from file "MachineConfig.txt";
					}
				}
				DeclarationSection Mixed_Integer_Programming_Support_Identifiers {
					ElementParameter ep_StartNoOverlap {
						IndexDomain: (i_al,i_o,i_hc);
						Range: HourCalendar;
					}
					ElementParameter ep_lineEnds {
						IndexDomain: i_al;
						Range: HourCalendar;
					}
					Parameter pureFormulation {
						Range: binary;
						InitialData: 0;
					}
					Parameter domStartProductionProductionLine {
						IndexDomain: (i_al,i_o,i_hc);
						Definition: {
							1 $ ( ( ( i_hc + ActivityLengthM1(i_al, i_o)/1[hour] ) <= EP_OrderDeliveryDate(i_o) ) or 
							      ( BP_D_OrderScheduledManuallyUsable(i_o)                                      )    )
						}
					}
				}
				DeclarationSection MIP_scheduling_declarations {
					Variable obj {
						Range: free;
						Unit: hour;
						Comment: "sum( i_al,  LineTotalSpan(i_al) )";
					}
					Constraint objDef {
						IndexDomain: | ( not pureFormulation );
						Unit: hour;
						Definition: {
							obj = sum( ( i_al, i_o, i_hc), 
							     CostOfStartingOrder(i_al, i_o, i_hc) )
						}
					}
					Variable SelectProcutionLine {
						IndexDomain: (i_al,i_o);
						Range: binary;
						Comment: "For every order i_o select precisely one production line i_al";
					}
					Variable LineTotalSpan {
						IndexDomain: i_al | pureFormulation;
						Range: free;
						Unit: hour;
						Definition: sum( ( i_o, i_hc), CostOfStartingOrder(i_al, i_o, i_hc) );
					}
					Variable StartProductionOnProductionLine {
						IndexDomain: (i_al, i_o, i_hc) | domStartProductionProductionLine(i_al, i_o, i_hc);
						Range: binary;
					}
					Variable CostOfStartingOrder {
						IndexDomain: (i_al,i_o,i_hc) | domStartProductionProductionLine(i_al, i_o, i_hc);
						Range: free;
						Unit: hour;
						Definition: ((ord(i_hc))[hour]+ActivityLength(i_al, i_o))  * StartProductionOnProductionLine(i_al, i_o, i_hc);
					}
					Constraint EnsureAnOrderIsHandledOnOneProductionLineOnly {
						IndexDomain: i_o;
						Definition: sum( i_al, SelectProcutionLine(i_al, i_o) ) = 1;
					}
					Constraint EnsureEachOrderIsStartedOnlyOnce {
						IndexDomain: (i_al,i_o);
						Definition: {
							sum( i_hc, StartProductionOnProductionLine(i_al, i_o, i_hc) ) = 
							     SelectProcutionLine(i_al, i_o)
						}
					}
					Constraint EnsureThereIsNoOverlapOnAnyLine {
						IndexDomain: (i_al,i_hc);
						Definition: {
							sum((i_o,i_hc1)| 
							      (ep_StartNoOverlap(i_al, i_o, i_hc)<=i_hc1) and 
							      (i_hc1<=i_hc), 
							  StartProductionOnProductionLine(i_al, i_o, i_hc1)) 
							  <=1
						}
					}
					Constraint MIPListenToManualScheduling {
						IndexDomain: i_o | BP_D_OrderScheduledManuallyUsable(i_o);
						Definition: {
							StartProductionOnProductionLine( 
							     ep_orderProductionLine(i_o), i_o, 
							     ep_orderStartDate(i_o) ) = 1
						}
					}
					Constraint JobsEndBeforemakespan {
						IndexDomain: i_al | pureFormulation;
						Unit: hour;
						Definition: LineTotalSpan(i_al) <= obj;
					}
				}
				DeclarationSection Mixed_Integer_Programming_Administration_Declarations {
					Set AllMixedIntegerProgrammingVariables {
						SubsetOf: AllVariables;
						Definition: ( Mixed_Integer_Programming_Scheduling_Model   ) * AllVariables;
					}
					Set AllMixedIntegerProgrammingConstraints {
						SubsetOf: AllConstraints;
						Definition: ( Mixed_Integer_Programming_Scheduling_Model   ) * AllConstraints;
					}
					MathematicalProgram MachineSchedulingMixedIntegerProgrammingFormulation {
						Objective: obj;
						Direction: minimize;
						Constraints: AllMixedIntegerProgrammingConstraints;
						Variables: AllMixedIntegerProgrammingVariables;
						Type: Automatic;
					}
				}
			}
		}
		Section Section_1 {
			ElementParameter startTimeActivity {
				IndexDomain: (i_al,i_o);
				Range: HourCalendar;
			}
			Parameter durationActivity {
				IndexDomain: (i_al,i_o);
				Unit: hour;
			}
			Procedure ReadBaseData {
				Body: {
					!read from file "MachineConfig.txt";
					!numberOfDaysInCalendar := 3 ;
					!read from file "ProductInfo.txt" ;
					!read from file "OrderBook.txt";
					! Read from file "Example1 5 machines 50 orders.txt" ;
					Read from file "Example2 3 machines 15 orders.txt" ;
					!read from file "MachineConfig.txt"
					bp_orderScheduledByHuman(i_o) := 0 ;
					
					!Empty EP_OrderStartDate, EP_OrderProductionLine;
				}
			}
			Procedure WriteAnotherBaseData {
				Body: {
					block where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
						write
							begHourCal, numberOfDaysInCalendar,
							S_AvailableLines, P_Capac,
							s_productNames, EP_ProductType,
							EP_OrderProduct, P_OrderQuantity, EP_OrderDeliveryDate
						to file
							"Example2 3 machines xx orders.txt" ;
					endblock ;
				}
			}
			Procedure pr_pageopen_Gantt_startUpProcedure {
				Body: {
					
					ReadBaseData();
				}
			}
		}
	}
	Section Application_initialization_and_termination {
		Procedure MainInitialization {
			Comment: "Add initialization statements here that do NOT require any library being initialized already.";
		}
		Procedure PostMainInitialization {
			Body: {
				! Workaround for gitlab ticket 4555:
				Empty p_latitude, p_longitude, p_locationSize ;
			}
			Comment: {
				"Add initialization statements here that require that the libraries are already initialized properly,
				or add statements that require the Data Management module to be initialized."
			}
		}
		Procedure PreMainTermination {
			Body: {
				return 1 ; ! Cases are not used in this app. DataManagementExit();
			}
			Comment: {
				"Add termination statements here that require all libraries to be still alive.
				Return 1 if you allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence."
			}
		}
		Procedure MainTermination {
			Body: {
				return 1;
			}
			Comment: {
				"Add termination statements here that do not require all libraries to be still alive.
				Return 1 to allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence.
				It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
			}
		}
	}
	Procedure MainExecution;
}
